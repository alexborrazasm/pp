
vamos a empezar por una más fácil.

Defina length: 'a list -> int

# [];;
- : 'a list = []  (* Un valor polimórfico que no es una función *)

let rec length l = 
    if l =[] then 0
    else 1 + length (List.tl l);;

let rec last l =
    if List.tl =[] then List.hd l
    else last (list.tl l);;



Falte el otro día,
siguiente día:

nos habla que el otro día dieron frases math with, ej esta función:

let rec compare_lengths l1 l2 =
    let p = l1, l2 in
    (function
          [], [] -> 0
        | [], _  -> -1
        |  _, [] -> 1
        | _::t1, _::t2 -> compare_lengths t1 t2) p;;


lo mimos que el de arriba:

let rec compare_lengths l1 l2 =
    (function
          [], [] -> 0
        | [], _  -> -1
        |  _, [] -> 1
        | _::t1, _::t2 -> compare_lengths t1 t2) (l1, l2);;

operador @
# (@);;
- : 'a list -> 'a list -> 'a list = <fun>

List.append
# List.append;;
- : 'a list -> 'a list -> 'a list = <fun>

# List.append [1; 2; 3] [4; 5];;
- : int list = [1; 2; 3; 4; 5]

Una lista o es lista vacia o tiene una cabeza y una cola. Las listas tienen naturaleza reculsiva.
vamos a definir nosotros append:

let rec append l1 l2 = match l1 with 
        [] -> l2                      (* Si l1 es vacia *)
      | h::t -> h :: append t l2      (* Si no es vacia *)

No es rec terminal, está así definita en el modulo List en o Ocaml.

# List.rev_append [1; 2; 3] [4; 5];;
- : int list = [3; 2; 1; 4; 5]

vamos a definirla:
let rec rev_append l1 l2 = match l1 with
        [] -> l2
      | h::t -> rev_append t (h::l2);;

Esta su es reculsiva terminal, es más natural el revappend que el append por como está construidas las listas en Ocaml

A partir de rev_append puedo definiar append recursivo terminal

# List.rev;;
- : 'a list -> 'a list = <fun>

es un caso particular de rev_append:

let rev l = rev_append l [];;

como hacer el append terminal:

let append' l1 l2 = rev_append (rev l1) l2;;

A partir de la versión 5 de Ocaml la append es terminal, en las anterior no lo era por lo lentas que eran las máquinas en su momento.

La no terminalidad de append tiene una particularidad, lo que deja pendiente es el contructor, son terminales salvo por el contructor
es constructor no es una "operación" como tal, si al compilador se lo pides puede compilar función así como terminal.
que es lo que han hecho en la versión 5 de ocaml. Como curiosidad.


A otra cosa, un tema recurrente, los errores de ejecución:
# 5 / 0;;
Exception: Division_by_zero.

esto en un programa nos pararia la ejecución del programa

# List.hd [];;
Exception: Failure "hd".
No puede devolver la cabeza de una lista vacia.

# List.tl [];;
Exception: Failure "tl".

# List.nth;;
- : 'a list -> int -> 'a = <fun>
nos devuelve el elemento que le pidamos de la lista
que pasa si aplicamos nth a un elemento que no exista

# List.nth [1; 2] 3;;
Exception: Failure "nth".

Y si accedemos a un elemento de una lista que no tiene sentido para ninguna
# List.nth [1; 2] (-1);;
Exception: Invalid_argument "List.nth".

Otros tipos de datos:
# Division_by_zero;;
- : exn = Division_by_zero

# Failure;;
Error: The constructor Failure expects 1 argument(s),
       but is applied here to 0 argument(s)

como constructor?

# Failure "menudo error!";;
- : exn = Failure "menudo error!"

el otro día definio está función:

let hd = function h::_ -> h;;

# let hd = function h::_ -> h;;
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
val hd : 'a list -> 'a = <fun>

Dejamos la lista vacia, que no tiene sentido, sin definir

# hd [];;
Exception: Match_failure ("//toplevel//", 1, 9).

entonces le puedes decir que el valor exn sea el adecuado con:
# raise;;
- : exn -> 'a = <fun>
Nunca devuelve nada, por eso devuelve del tipo que quiera

# raise Division_by_zero;;
Exception: Division_by_zero.

No devuleve si no que da el error.


let hd = function 
    [] -> raise (Failure "hd")      
   | h::_ -> h;;


Otro día:

se pone a programar en Ocaml de chill:

let rec lmax1 = function
    [] -> raise (Failure "lmax1")
  | h::[] -> h
  | h::t -> if h >= lmax1 t then h
            else lmax1 t;;

#No es admisoble hacer el mismo cálculo 2 veces, eso de arriba MAL, MUY GRAVE
Como se evita? con una definición local

let rec lmax2 = function
    [] -> raise (Failure "lmax2")
  | h::[] -> h
  | h::t -> let m = lmax2 t in
            if h >= m t then h
            else m;;

 #Las 2 son una función que devuelve el valor más alto de una lista
No es terminal, si hago muchos pasos puedo tener stack overflow, pero si no tengo stack overflow dará un resultado y este será el máx de la lista
lmax1 no va a dar stack overflow por que el máximo número de operaciones pendiantes es la longitud de la lista

Como crear una lista, no me dió tiempo de copiar

Vamos a hacerla reculsiva terminal:
Necesito un "acumulador" ej:
[1,2,3,4]
1 [2,3,4]
2 [3,4]
3 [4]
4

let lmax' = function
    [] -> raise (Failure "lmax2")
  | h::t -> let rec loop m = function
                [] -> m
              | h::t -> loop (max m h) t
            in loop h t;;

Ahora es reculsiva terminal
Otra versión más bonita y sencilla reculsiva terminal:

let rec lmax = function
    [] -> raise (Failure "lmax2")
  | h::[] -> h
  | h1::h2::t -> lmax (max h1 h2 :: t);; (* Basicamente quito de los 2 primeros elementos el que no es el maximo de los 2 *)

Tiene algún inconveniente lmax sobre lmax'?
  Si tiene que ver sobre el caso de 1 elemento, cada vez que se aplica mira si tiene un elemento la lista, en lmax' no.
  lmax tiene que distingir 3 casos y lmax' solo 2, aunque tienen la misma complejidad si que se podría notar en el cálculo esa operación.

Vamos a hablar de List.fold_left;;

# List.fold_left;;
- : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = <fun>

Tiene 3 argumentos
Coje una operación binaria y la aplica a una lista

# List.fold_left (+) 7 [2;3;4];;
- : int = 16

# List.fold_left (+) 7 [0;1];;
- : int = 8

Se puede definir length usando List.fold_left


otro día:

La importancia del folld_left, dado que se puede simplificar muchas operaciones de listas, a partir de ahora si queremos hacer algo reculsivo terminal
podemos utilizar, si procede, el fold_left.

MIRAR FOLD_LEFT

HACER last con fold_left

let last (h::t) =
  List.fold_left (fun _ x -> x) h t;;

Ahora vamos con algo nuevo, pero seguimos en listas:

Vamos a dar algoritmos de ordenación pora listas

insercción y quicksort o fusión

(* Shorted: 'a list -> bool) *)

# (<=) 2 4;;
- : bool = true

# 2 <= 4;;
- : bool = true

let rec shorted = function
    [] -> true
  | h::[] -> true
(* Esto se puede juntar*)

let rec shorted = function
    [] | h::[] -> true
  | h1::h2::t -> h1 <= h2 && sorted (h2::t);;  (* Si es terminal, la cunjunción y las disyunción son if camuflados *)

(* El mejor caso es que no estea ordenada y el mejor que estea ordenado *)

(* Ahora ordenación por insercción *)

(* insert : a' -> a' list -> a' list *)
let rec insert x = function   (* Prometo no usarla con listas no ordenadas *)
    [] -> [x]
  | h::t -> if x <= h then x :: h :: t
            else h :: insert x t;;  (* No es reculsiva terminal, falta el ::, aunque este tipo de no terminalidad puede ser terminal indicandolo al compilador *)

(* Un buen ejercicio es hacer la versión terminal *)

(* isort: 'a list -> 'a list *)

let rec isort = function
    [] -> []
  | h::t -> insert h (isort t);; (* No seria terminal aunque insert lo sea *)

(* Segundo ejercicio, versión terminal de isort *)
(* Caso favorable linear, medio y peor cuadrático *)
(* Un ejercicio así interesante es pasarle listas diferentes y ver como crece *)
(* De donde saco una lista aleatiio en camel?*)
Random.int;; es una falsa función
aplicado al int n, devuelve un entero menor que n y mayor igual que 0

let list = List.init 100_000 (fun _ -> Random.int 400_000);;

(* Si las quiero ordenar en otro orden, podría hacer que el orden sea un argumento *)

(* g_shorted: 'a -> 'a -> -> bool) *)
let rec g_shorted ord = function
    [] | h::[] -> true
  | h1::h2::t -> ord h1 h2 && g_sorted ord (h2::t);;

(* Añadir a las otras 2 orden como argumento *)

Otro día, ordenación por fusión:

(* divide 'a list -> 'a list * 'a list *)
let rec divide = function
    [] -> [], []
  | [h] -> [h], []
  | h1::h2::t -> let t1, t2 = divide t
                 in h1::t1,h2::t2;;
(* Nos va a divide una lista en 2 lístas lo más equilibrada posible 
No es terminal, puede haber stack overflow 
Ejercicio hacerlo terminal 
Complejidad lineal, número de pasos es el n de elementos dividido entre 2 *)

(* merge 'a list * 'a list -> 'a list *)
let rec merge = function    (* Solo devuelve una lista ordenada si las listas de los pares están ordenadas *)
    (h1::t1, h2::t2) -> if h1 <= h2 then h1 :: merge (t1, h2::t2)
                        else h2 :: merge (h1::t1, t2)
  | [], l | l, [] -> l;;  (* Aqui se incluye el caso [] [] *)
(* Ejercicio versión terminal de merge *)

(* a' list -> a' list *)
let rec msort = function
    [] -> []  | [l] -> l
  | l -> let l1, l2 = divide l
         in merge (msort l1 , msort l2);;

(* msort no es terminal, es dificil, nunca lo va a pedir en un examen *)
(* En nuestro universo nunca va a ocurrir que msort de stack overlow, dado que estás dividiento, para 1000 elementos llamas log2 1000 *)
(* Queda como último ejercio incorporar el orden como elemento *)

(* Si me da a' list a b' list quiere decir que no devuelve nada, igual que pasa con raise de exn -> 'a *)
(* En el modulo list esta la función sort que ordena, también se le pasa el orden como argumento, esta hecha con este método de fusión *)



OTRO DÍA:

vamos a resolver el problema de las reinas

Al igual que para cada tipo 'a hay un 'a list, también para cada tipo de datos 'a existe 'a option.

Como son los valores 'a option? int option o string option etc.

[] es del tipo 'a list

Aqui el valor none: 'a option

None es uno de los constructores de los valores de tipo option

Same también

como vemos en Ocaml todos los constructores van con la primera letras mayúscula.

Solo tenemos 2 constructores Some y None.

Es para buscar algo equivalente que de la misma información. Como en mates cuando una función no tiene imagen y le damos
otra función para cuando entramos donde la original no tiene imagen.

List.find da error si no encuntra

List.fin_opt da None al fallar y un int option al estar bien

let par = fun x -> x mod 2 = 0 

let print_fisrt_even l =
  print_endline (string_of_int (List.find_opt par l));;

let print_first_even l =
  match List.find_opt par l with
      None -> print_endline "Ningún par"
    | Sone n -> print_endline (string_of_int (List.find_opt par l));;

La última no se termina el programa, en la primera al no encontrar el número veremos que se para el programa y igual no queremos.

-----------------------------------------------------------------------------------------------------------------------------------
Vamos al programa de las 8 reinas:

El desafio es poner 8 reinas en un tablero de ajedrez y que no se coman las reinas.

No hay una sola manera.

La solución la puedo dar como una lista de pares de enteros.

Primero vamos a hacerlo en un tablaro 4x4 en lugar de 8x8 la primera vez, para entender la orden

En un cuadro 1x1 podemos colocar una en [1,1]
En el 2x2 no es posible
En el 3x3 no es posible
En el 4x4 si, porcierto en el tablero 0x0 tambien es posible, []

0x0 -> Some []
1x1 -> Some [(1,1)]
2x2 -> None
3x3 -> None
4x4 -> ?

A partir de 4x4 está estudiado que a apartir del 4 tengo solución.

Backtraking, es una mierda en imperactivo, aqui no, es proceso de buscar en arbol y volver hacia atrás

Vamos a intentar implementarla.

En primer lugar vamos a hacer una función auxiliar que mire si una reina come a otra 

let come (i1,j1) (i2,j2) =
  i1 = i2 || j1 = j2 || abs (i2-i1) = abs (j2 - j1);;

let compatible p l =
  not (List.exists (come p) l);;

let queens n =
  let rec completar path i j =
    if i > n then Some path   (* Hemos terminado *)
    else if j > n then None   (* No se puede completar *)
    else if compatible (i,j) path
         then completar path ((icj)::path) (i+1) 1 (* Esta frase está mal, que pasa si da none? Nos lo deja a completar *)
         else completar path i (j+1)
    in completar [] 1 1;;

iNTENTAR SI ME SALE RÁPIDO, HACER UNA FUNCIÓN QUE EN LUGAR DE UNA SOLUCIÓN ME DEA TODAS LAS QUE HAY

OTRO DÍA, viernes 17:

Terminamos la función:

let queens n =
  let rec completar path i j =
    if i > n then Some path   (* Hemos terminado *)
    else if j > n then None   (* No se puede completar *)
    else if compatible (i,j) path
            then match completar path ((i,j)::path) (i+1) 1 with
                  None -> completar path i (j+1)
                | Some sol -> Some sol
         else completar oath i (j+1)
    in completar [] 1 1;;
  
vamos a escribirlo sin None y Some, a la tradicional:

let queens n =
  let rec completar path i j =
    if i > n then path                   (* Hemos terminado *)
    else if j > n then raise Not_found   (* No se puede completar *)
    else if compatible (i,j) path 
      then try completar ((i,j)::path) (i+1) 1 with
            | Not_found -> completar path i (j+1)
    else completar path i (j+1)
  in completar [] 1 1;;
(* Try _________ with, se evalua lo que hay en la mitad, si da fallo hace lo que le digamos*)


Como es una try with en general:

try <e> with 
    <p1> -> <e1>
  | <p2> -> <e2>
  | ...

  si e no da fallo non pasa nada, si lo da hace patern maching con lo que tiene a continuación

  se interceptan los errores de e1

Un par de ejemplos más del uso del try with:

List.find_opt esta a diferencia de List.find nunca falla, dado que si falla devuelve none y si no same loquesea

# List.find_opt;;
- : ('a -> bool) -> 'a list -> 'a option = <fun>
# List.find;;
- : ('a -> bool) -> 'a list -> 'a = <fun>

Como se define find_opt?

es más sencillo definir find_opt usando ya el find ya definido

let find_opt p l =
  try Some (List.find p l) with
    Not_found -> None;;

val find_opt : ('a -> bool) -> 'a list -> 'a option = <fun>

Si pusiera:

_ -> Nose 

que pasa? interceptaria todos los errores, peligro

otro ejemplo, List.nth:

# List.nth [1;2;3] 4;;
Exception: Failure "nth".

# List.nth [1;2;3] (-1);;
Exception: Invalid_argument "List.nth".

vamos a definir nth_opt

let nth_opt l n =
  try Some (List.nth l n) witch
      _ -> None;;       (* Puedo interceptar todo, dado que creo que solo puede dar 2 fallos *)

let nth_opt l n =
  try Some (List.nth l n) witch
      Failure "nth" -> None;;     (* Puede ser un problema es sting, dado que si en una versión de List.nth cambian el "nth" por otra cosa esta función deja de funcionar, dificil decisión *)

Detallito de lo que va a dar la semana que viene:
Vamos a empezar a definir tipos de datos, queeee?
sachada

Para definir un tipo de datos en Ocaml se empieza por la palabra reservada type

ej:

type numero = I of int | F of float;;


Aqui tenemos que definir nosotros los contructores que pasen de int a numero y de float a numero

# type numero = I of int | F of float;;
type numero = I of int | F of float

# I 4;;
- : numero = I 4
# F 2.4;;
- : numero = F 2.4

# [I 3; F 2.3; I 5];;
- : numero list = [I 3; F 2.3; I 5]

UNA FUNCIÓN QUE DEVUELVE EL PRIMER ENTERO

let is_int = function
    I _ -> true | _ -> false;;

let rec first_int = function
    [] -> raise Not_found
  | I n :: _ -> n
  | _ :: t -> first_int t;;

---------------------------------------------------------------------------------------------------------------------------------------------------------------
otro día:

type otroint = Otro of int;;
type otroint = Otro of int

# Otro 1;;
- : otroint = Otro 1
# Otro 6;;
- : otroint = Otro 6


type dobleint = R of int | L of int;;

# R 5;;
- : dobleint = R 5
# L 5;;
- : dobleint = L 5
# R 10;;
- : dobleint = R 10
# L 10;;
- : dobleint = L 10
# L 10 = R 10;;
- : bool = false
No son iguales dado que no estás construidos con el mismo contructor

Si no existieran los int option, podria hacerlo asi:

type intplus = Int of int | Na;;
Int es un constructor varaible y Na constante

# Na;;
- : intplus = Na
# Int 4;;
- : intplus = Int 4
# Int 10;;
- : intplus = Int 10

Se podría usar como un int option.

vamos a definir la división entera si que al dividir por 0 dera error.

let div i1 i2 = match (i1,i2) with
    (_, Int 0) -> Na
  | (Int m, Int n) -> Int (m / n);;
  | _ -> Na;;   (* En cualquier otro caso *)

  como pasr de (/) i1 i2 a i1 / i2:

  let (//) = div;;

  ya está

  tambien le podria llamar directamente (//) a la función div

Otro ejemplo:

type boolean = True | False;;

podría hacer un boolean que fuera negro blanco o de 3 valores etc.

let no = function
    True -> False
  | False -> True;;

podría hacerlo como en algún lenguaje:

let (!) = function
    True -> False
  | False -> True;;

# !True;;
- : boolean = False

Otro ejemplo:

type palo = Diamente | Corazon | Trebol | Pica;;

let es_rojo = function
    Corazon | Diamante -> True
  | _ -> False;;

let es_negro p = ! (esrojo p);;

Otro ejemplo:

type nat = One | Succ of nat;;  (* Es una definición reculsiva *)

# One;;
- : nat = One
# Succ One;;
- : nat = Succ One
# Succ (Succ One);;
- : nat = Succ (Succ One)

let rec nat_of_int = function 
    1 -> One
  | n -> Succ (nat_of_int (n-1));;

(* Si le pasamos un número negativo o 0 no stack overflow y si fuera terminal daria la vuelta a int hasta llegar a 1 *)
(* Ejercicio, añadir un error para número no validos y hacerlo terminal *)

type entero = Pos of nat | Neg of nat | Zero;;

let absoluto = function
    Neg n -> Pos n
  | e -> e;;

let opuesto = function
    Zero -> Zero
  | Pos n -> Neg n
  | Neg n -> Pos n;;

let entero_of_int = function
    0 -> Zero
  | n -> if n > 0 then Pos (nat_of_int n)
         else Neg (nat_of_int (-n));;


type 'a option = None | Some of 'a;; (* Tipo polimórfico *) OPTION NO ES UN TIPO ES UN CONTRUCCIÓN DE TIPOS

Así están definidos los tipos optión del otro día.


AHORA VA A JUNTAR TODO AHHHHHHHHHHHHHHHHH:

type 'a lista = Vacia | Cons of 'a * 'a lista;;

# Vacia;;
- : 'a lista = Vacia
# Cons (3, Vacia);;
- : int lista = Cons (3, Vacia)
# Cons (2,Vacia);;
- : int lista = Cons (2, Vacia)
# let l3 = Cons (3, Vacia);;
val l3 : int lista = Cons (3, Vacia)
# let l33 = Cons (3, l3);;
val l33 : int lista = Cons (3, Cons (3, Vacia))

Tenemos las list definidas

El viernes nos contará algo que no viene definido el Ocaml.

árboles binarios

type 'a bintree = bien ejercicio pensarlo

Las listas son arboles unarios, con solo una rama


HA FALTADO EL VIERNES, LO SIENTO ALEX DEL FUTURO

siguiente clase 28 nov:

debio dar arboles binarios por lo que dijo
ahora está hablando de arbiles estrictamente binarios o no

type 'a bintree =
    Empty 
  | Node of 'a = 'a bintree * 'a bintree;;

let rec nodos = function
    Empty -> 0
  | Node (_,i,d) -> 1 + nnodos i + nnodos d;;

let rec altura = function
    Empty -> 0
  | Node (_,i,d) -> i + nnodos i + nnodos d;;

let rec tmax = function
    Empty -> raise (Invalid_argument "tmax")
  | Node me falta cosas



otro, esto era del otro día que no vine

Con esto voy a representar cualquier árbol estrictamente binario

type 'a st_bintree =
    Node of 'a * 'a st_bintree * 'a st_bintree
  | Leaf of 'a;;

let rec hojas = function
    Leaf v -> [v]
  | Node (_, i, d) -> hojas i @ hojas d;;

un árbol que no pueda tener el arbol vacio:

type 'a ne_bintree =
    Node of 'a * 'a ne_bintree option * 'a ne_bintree option;;

Entran todos menos los vacios

let leaf v = Node (v, []);;

let t_6 = Node (6,[leaf (5; lead 11)]);;

faltan cosas

let rec nnodos Node (_, lr) =
    List.fold_left (+) 1 List.map nnodos lr;;

let rec nnodos Node (_, lr) =
    List.fold_left (fun n t -> n + nodos t) 1 lr;;

cualquier árbol que tenga, al menos, una rama se puede dividir en 2 árboles, entonces:

let rec nnodos = function 
    Node (_, []) -> 1
  | Node (r, h::t) -> nnodos h + nnodos (Node (r, t));;

la mejor, la última, QUEDAN 6 CLASES AAAAAAAAAAAAAAAAAH

proxima día el lado oscuro, la parte imperativa del lenguaje, venir preparados

como se carga un módulo, #load "counter.cmo";;
Counter.next;;

Si no quiero poner counter pongo, open Counter;;


Otro día, falte el viernes, dio la aparte imperativa del lenguaje y ahora toca seguir
habla de ;

match <e> with es similar a un switch

vamos con los bucles:

<b> bool

while <b> do <e> done

cuando es false daria un unit y si no evalua e

let rec fact n =
  if n <= 0 then 1
  else n * fact (n-1);;

hacer esta función pero sin usar rec

un bucle sin variables no sirve para nadaw, en funcional algo que se evalue false o true siempre será false o true;

vamos alla:

let fact n = 
  let f = ref 1 in
  let i = ref 1 in 
  while !i <= n do
    f:= !f * !i;
    i := !i + 1
  done;
  !f;;

como vemos los bucles son más parecidos a la tail reculsion

let fect n =
  let rec aux (f,i) =
    if i <= n then
      aux (f * i, i + 1)
    else f
  in aux (1,1);;

bucle for:

for <i> = <i1> to <i2>
  do <e> done

for <i> = <i1> down to <i2>
  do <e> done

fact sin recursividad y sin el bucle while:

let fact n =
  let f = ref 1 in
  for i = 1 to n do
      f := !f * i
  done;
  !f;;

vamos a aumentar la diversión del imperactivo

let v = [|1; 10; 100|];;
val v : int array = [|1; 10; 100|]
no es una lista, mmmmmmmmmm
diferecias con la int list:
-rendimiento, en a' array puedes acceder al elemento de cualquiera posición con coste constante, adiferencia de las listas
-los array está numerados, de 0 a (n9-1)
-tambien tenemos el módulo Array

# Array.length;;
- : 'a array -> int = <fun>

# Array.get;;  (* Similar a nth pero co coste constante *)
- : 'a array -> int -> 'a = <fun>

abrebiado, v.(1);;

# v.(1);;
- : int = 10

recuerda que puedes dejar de llamar al modulp por Array.nombre con open Array

# open Array;;
# set v 2 (v.(1) + 2* v.(2));;
- : unit = ()
# v;;
- : int array = [|1; 10; 210|]

devuelve unit, pero no nos importa lo que devuelva, lo importante es que cambia v

v.(2) <- v.(1) + 2 * v.(2);; (* set abreviado *)

# v.(2) <- v.(1) + 2 * v.(2);;
- : unit = ()
# v;;
- : int array = [|1; 10; 430|]

existe init para array?

# Array.init 20 succ;;
- : int array =
[|1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20|]

# make 10_000 'a';;
- : char array =
[|'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a';...|]

array de 10_000 char 'a', igual que el de List.make pero para Array

Array.copy hace una copia del array en ese momento

en rec con ! nos referimos al valor, similar a punteros parece, mirar.


TREMENDO PUENTE, VUELTA A CLASE, MARTES 12

type person = {name : string; age : int}

que es? un regustro de datos, un struct en C.

tiene 2 componentes un string y un int.

es un registro de 2 campos.

se puede hacer patermaching en los registros

older : person -> person

let order p =
  {name = p.name; age = p.age + 1};;

let older {name = n; age = a} =
  {name = n; age = a + 1};;

let older p =
  {p with age = p.age + 1; name = ""};;

puedo hacer otra definición de los registros:

type person = {name : string; mutable age : int}

let p2 : person = {name = "Marta"; age = 18}

como modifico el valor mutable?

p2.age <- 28;;

let aged p <- p.age + 1;;

aged p2; p2;; ahora así puedo imprimir el valor

type 'a var = {mutable valor : 'a};;

# {valor = 1};;
- : int var = {valor = 1}
# {valor = "Hola"};;
- : string var = {valor = "Hola"}

let initvar x = {valor = x};;

# initvar 10;;
- : int var = {valor = 10}
# initvar "Casa";;
- : string var = {valor = "Casa"}

let (!!) v = v.valor;;

let n = initvar 7;;

# let n = initvar 7;;
val n : int var = {valor = 7}
# !!n;;
- : int = 7

ACABO DE IMPLEMENTAR LAS VARIABLES EN OCAML, de hecho así están implementadas en Ocaml.

cambiamos de tema: ejemplo antiguo

la función next:

let n = ref 0

let next () = 
  n := !n + 1;
  !n

let reset () =
  n := 0

sin usar una variable global:

let next  =
  let n ref 0 in
    function () ->
    n := !n + 1;
    !n;;

pero como hacemos ahora el reset?

let next, reset =
  let n = ref 0 in
  (function () -> n := !n + 1; !n),
  (function () -> n := 0);;

  Otra menera seria usar un módulo

todo este tiempo con ocamlc algo.ml -i algo.mli estabamos compilando modulos

para cargarlos en el compilador interactivo #load "counter.cmo";;

entre comillas la ruta

HACER UN MÓDULO EN UN SOLO FICHERO:

module Contador : sig
  val next : unit -> int
  val reset : unit -> unit
end = struct
  let n = ref 0
  let next () = 
    n := !n + 1;
    !n
  let reset () =
    n := 0
end

esto es una fuctor, es como una funcion pero devuelve módulos

module Contador () : sig
  val next : unit -> int
  val reset : unit -> unit
end = struct
  let n = ref 0
  let next () = 
    n := !n + 1;
    !n
  let reset () =
    n := 0
end

module Contador :
  functor () -> sig val next : unit -> int val reset : unit -> unit end

# module Carne = Contador ();;
module Carne : sig val next : unit -> int val reset : unit -> unit end
# module Fruta = Contador ();;
module Fruta : sig val next : unit -> int val reset : unit -> unit end
# module Peixe = Contador ();;
module Peixe : sig val next : unit -> int val reset : unit -> unit end

BRUTAL

hay muchos módulos que no son módulos, son functor, entonces lo que pasa es que te crea modulos

OTRO DÍA VIERNES

habla de next, que se podŕia hacer con modulos

el uso de funtores, que son funciones que devuelven modulos, que si necesitamos varios next por ejemplo
los podría hacer con un funtor, en lugar de definir el modulo varias veces.

ESTES MODULOS PUEDEN FUNCIONAR COMO OBJETOS

los registros o structs en C, también podría funcionar next

type counter = {next : unit -> int ; reset: unit -> unit}

let counter = 
  let n = ref 0 in
  {next = (function () -> incr n; !n); 
   reset = (function () -> n := 0)};;

A todo esto existe la función incr;;
# incr;;
- : int ref -> unit = <fun>

# counter.next ();;
- : int = 1
# counter.next ();;
- : int = 2
# counter.next ();;
- : int = 3
# counter.next ();;
- : int = 4
# counter.next ();;
- : int = 5
# counter.reset ();;
- : unit = ()
# counter.next ();;
- : int = 1
# counter.next ();;
- : int = 2

lo mismo que con modulos

los registros pueden funcionar como módulos

también podría hacer una función que devuelva un counter, como con los funtores

let new_counter () =
  let n = ref 0 in
  {next = (function () -> incr n; !n); 
   reset = (function () -> n := 0)};;

# let c = new_counter ();;
val c : counter = {next = <fun>; reset = <fun>}
# let c' = new_counter ();;
val c' : counter = {next = <fun>; reset = <fun>}
# c.next ();;
- : int = 1
# c.next ();;
- : int = 2
# c'.next ();;
- : int = 1


VAMOS CON OBJETOS
en Ocaml no se suele usar por las formas alternativas de hacer las cosas

let counter = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

val counter : < next : int; reset : unit > = <obj>

2 métodos, el next y el reset

todos los objetos que tengan 2 metodos en ocaml son del mismo tipo

un propiedad de los obj es que cambian de estado, normalmente esto se representa con una variable, mutable
no es lo mismo que un 'a ref, es mucho más parecido a un registro "en C" o elementos de un vector

# counter#next;;
- : int = 1
# counter#next;;
- : int = 2
# counter#next;;
- : int = 3
# counter#next;;
- : int = 4
# counter#reset;;
- : unit = ()
# counter#next;;
- : int = 1
# counter#next;;
- : int = 2

se invocan con nombre del objeto#metodo

# counter#next;;
- : int = 4
# counter#next + (counter#reset; 2 * counter#next);;
- : int = 4

ojo, no ha dado 7, por que? por que se avalua primero la expresión de la derecha

MUCHO CUIDADO

let doble o = 2 * o#next;;

# let doble o = 2 * o#next;;
val doble : < next : int; .. > -> int = <fun>

POLIMORFIMOS CON OBJETOS ARRIBA, con registros no podría hacerlo, solo valdría para ese tipo de registros

# counter#next;;
- : int = 1
# doble counter;;
- : int = 4

let counter' = object
  val mutable n = 100
  method next = n <- n + 2 ; n    (* Suma 1 *)
end;;

val counter' : < next : int > = <obj>

# doble counter';;
- : int = 204

# doble counter';;
- : int = 208

counter y counter' no son del mismo tipo, pero gracias al polimorfismo en obj puedo aplicar la función doble,
está solo requiere que un obj tenga una función del tipo next de tipo int

let doble_o o = object
  val mutable n = o#next
  method next = n <- n + 3; n
end;;
val doble_o : < next : int; .. > -> < next : int > = <fun>

# doble_o counter;;
- : < next : int > = <obj>
# doble_o counter';;
- : < next : int > = <obj>

# let c3 = doble_o counter' ;;
val c3 : < next : int > = <obj>
# c3#next;;
- : int = 113

AHORA quiro crear varios obj del mismo tipo, como con los modulos y los registros
un función

let new_counter () = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

val new_counter : unit -> < next : int; reset : unit > = <fun>

# let c1 = new_counter ();;
val c1 : < next : int; reset : unit > = <obj>
# let c2 = new_counter ();;
val c2 : < next : int; reset : unit > = <obj>
# let c3 = new_counter ();;
val c3 : < next : int; reset : unit > = <obj>
# c1#next;;
- : int = 1
# c1#next;;
- : int = 2
# c2#next;;
- : int = 1
# c3#next;;
- : int = 1
# c3#next;;
- : int = 2
# c2#next;;
- : int = 2

c1, c2, c3 son del mismo tipo

# [c1;c2;c3];;
- : < next : int; reset : unit > list = [<obj>; <obj>; <obj>]

que falta aqui? las clases

que es una clase?
normalmente en los lenjuages orientados a abj tenemos que definiar la clase antes que los obj
aqui puedo tener obj sin clase, pero tambien existen las clases, en ocaml podría vivir sin las clases

las clases proporcionan la caracteristicas de la herencia, con la función new_counter no lo tengo
hasta ahora aqui hice objcetos inmediatos

como creo obj como clases?

una clase es una receta para crear obj

class new_counter = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

class new_counter :
  object val mutable n : int method next : int method reset : unit end

# let cc = new new_counter;;
val cc : new_counter = <obj>

# cc;;
- : new_counter = <obj>

cuando defino clases lo que estoy haciendo es definir un alias, para un tipo de obj, ahora new_counter es el nombre de los
obj que tienen el metodo reset y next

pero son del mismo tipo

# [c1;cc];;
- : new_counter list = [<obj>; <obj>]

---------------------------------------------
OTRO DÍA:
los objetos son valores, y hablamos del polimorfismo de los objetos

object atributos end

let c2 = new_counter ();;

para definir clases era:

new counter

class counter = object
	val mutable n = 0
	method next = n <- n + 1 ; n
	nethod reset : int
end;;

class counter_with_set = obsject
	inherit counter
	method set x = n <- x
end;;

algo de la clase counter_with_set no seria igual al tipo counter, pero lo podría restringir,
con:

c5 :> counter, siendo c5 un valor del tipo counter_with_set

entonces ahora podría hacer una lista de counter con c5

aunque en la lista se usa como  un counter, yo ouedo acceder a el con set y modificarlo y se modifica en la lista con set

ME MUERO PUTA MERDA DE CATARRO

inherit heredar de una clase anterior

se puede editar un clase, ej:

class counter_with_init ini = object (self)
	inherit counter_with_set
	method reset = (* n <- ini *)
			self#set ini
	initializer (* n <- ini *) self#reset
end;;

alias para hacer referencia a los elementos de la clase, metodo inicializador

un metodo permite una espacio de reculsibidad abierta

class counter_with_init'n'fin ini fin = object (self)
	inherit counter_with_init ini as super
	method next = let next = super#next in
		      if next < fin then next
		      else (self#reset; super#next)
end;;

se podría modificar el paso, un contador de step en step

class counter_with_step = object (self)
	inherit counter_with_init 0 as super
	val mutable step = 0
	method next = n <- n + step; n
	method set_step s = step <- s
	method reset = super#reset; self#set_step 1
end;;

esto como vemos es muy laborioso para hacer estas cosas, tenemos maneras más eficientes para la maquina y menos complicadas de escribir

esto tiene sentido sobre todo para interfaces web, donde tenemos widgets que se llaman etc.

en el moodle puso capitulos de libros que hablan más de objetos en ocaml, y las clases de la pandemia de objetos

polimorfismo con clases:

class ['a] stack =
	object
	   val mutable l = ([] : 'a list)	(* instance variable *)
	   method push x =
	      l <- x :: l
	   method pop = match l with 		(* push method *)
	      [] -> raise EmptyStack
	    | h::t -> l <- t; h
	   method peek = match l with		(* peek method *)
	      [] -> raise EmptyStack
            | h::_ -> h
end;;

maldita la falta que hacia definir esto como un objeto, dado que las listas en ocaml, ya trabajan como un stack


viernes no hay clase, materia por terminada, preguntemos lo que queramos por teams, día 30 es el límite

podemos traer notas apuntes, cosas que quepan en el pupitre y cada uno para si mismo xd

