Terminamos la función:



Como es una try with en general:

try <e> with 
    <p1> -> <e1>
  | <p2> -> <e2>
  | ...

  

Un par de ejemplos más del uso del try with:

List.find_opt esta a diferencia de List.find nunca falla, dado que si falla devuelve none y si no same loquesea

# List.find_opt;;
- : ('a -> bool) -> 'a list -> 'a option = <fun>
# List.find;;
- : ('a -> bool) -> 'a list -> 'a = <fun>

Como se define find_opt?

es más sencillo definir find_opt usando ya el find ya definido

let find_opt p l =
  try Some (List.find p l) with
    Not_found -> None;;

val find_opt : ('a -> bool) -> 'a list -> 'a option = <fun>

Si pusiera:

_ -> Nose 

que pasa? interceptaria todos los errores, peligro

otro ejemplo, List.nth:

# List.nth [1;2;3] 4;;
Exception: Failure "nth".

# List.nth [1;2;3] (-1);;
Exception: Invalid_argument "List.nth".

vamos a definir nth_opt

let nth_opt l n =
  try Some (List.nth l n) witch
      _ -> None;;       (* Puedo interceptar todo, dado que creo que solo puede dar 2 fallos *)

let nth_opt l n =
  try Some (List.nth l n) witch
      Failure "nth" -> None;;     (* Puede ser un problema es sting, dado que si en una versión de List.nth cambian el "nth" por otra cosa esta función deja de funcionar, dificil decisión *)





      
Detallito de lo que va a dar la semana que viene:
Vamos a empezar a definir tipos de datos, queeee?
sachada

Para definir un tipo de datos en Ocaml se empieza por la palabra reservada type

ej:

type numero = I of int | F of float;;


Aqui tenemos que definir nosotros los contructores que pasen de int a numero y de float a numero

# type numero = I of int | F of float;;
type numero = I of int | F of float

# I 4;;
- : numero = I 4
# F 2.4;;
- : numero = F 2.4

# [I 3; F 2.3; I 5];;
- : numero list = [I 3; F 2.3; I 5]

UNA FUNCIÓN QUE DEVUELVE EL PRIMER ENTERO

let is_int = function
    I _ -> true | _ -> false;;

let rec first_int = function
    [] -> raise Not_found
  | I n :: _ -> n
  | _ :: t -> first_int t;;

---------------------------------------------------------------------------------------------------------------------------------------------------------------
otro día:

type otroint = Otro of int;;
type otroint = Otro of int

# Otro 1;;
- : otroint = Otro 1
# Otro 6;;
- : otroint = Otro 6


type dobleint = R of int | L of int;;

# R 5;;
- : dobleint = R 5
# L 5;;
- : dobleint = L 5
# R 10;;
- : dobleint = R 10
# L 10;;
- : dobleint = L 10
# L 10 = R 10;;
- : bool = false
No son iguales dado que no estás construidos con el mismo contructor

Si no existieran los int option, podria hacerlo asi:

type intplus = Int of int | Na;;
Int es un constructor varaible y Na constante

# Na;;
- : intplus = Na
# Int 4;;
- : intplus = Int 4
# Int 10;;
- : intplus = Int 10

Se podría usar como un int option.

vamos a definir la división entera si que al dividir por 0 dera error.

let div i1 i2 = match (i1,i2) with
    (_, Int 0) -> Na
  | (Int m, Int n) -> Int (m / n);;
  | _ -> Na;;   (* En cualquier otro caso *)

  como pasr de (/) i1 i2 a i1 / i2:

  let (//) = div;;

  ya está

  tambien le podria llamar directamente (//) a la función div

Otro ejemplo:

type boolean = True | False;;

podría hacer un boolean que fuera negro blanco o de 3 valores etc.

let no = function
    True -> False
  | False -> True;;

podría hacerlo como en algún lenguaje:

let (!) = function
    True -> False
  | False -> True;;

# !True;;
- : boolean = False

Otro ejemplo:

type palo = Diamente | Corazon | Trebol | Pica;;

let es_rojo = function
    Corazon | Diamante -> True
  | _ -> False;;

let es_negro p = ! (esrojo p);;

Otro ejemplo:

type nat = One | Succ of nat;;  (* Es una definición reculsiva *)

# One;;
- : nat = One
# Succ One;;
- : nat = Succ One
# Succ (Succ One);;
- : nat = Succ (Succ One)

let rec nat_of_int = function 
    1 -> One
  | n -> Succ (nat_of_int (n-1));;

(* Si le pasamos un número negativo o 0 no stack overflow y si fuera terminal daria la vuelta a int hasta llegar a 1 *)
(* Ejercicio, añadir un error para número no validos y hacerlo terminal *)

type entero = Pos of nat | Neg of nat | Zero;;

let absoluto = function
    Neg n -> Pos n
  | e -> e;;

let opuesto = function
    Zero -> Zero
  | Pos n -> Neg n
  | Neg n -> Pos n;;

let entero_of_int = function
    0 -> Zero
  | n -> if n > 0 then Pos (nat_of_int n)
         else Neg (nat_of_int (-n));;


type 'a option = None | Some of 'a;; (* Tipo polimórfico *) OPTION NO ES UN TIPO ES UN CONTRUCCIÓN DE TIPOS

Así están definidos los tipos optión del otro día.


AHORA VA A JUNTAR TODO AHHHHHHHHHHHHHHHHH:

type 'a lista = Vacia | Cons of 'a * 'a lista;;

# Vacia;;
- : 'a lista = Vacia
# Cons (3, Vacia);;
- : int lista = Cons (3, Vacia)
# Cons (2,Vacia);;
- : int lista = Cons (2, Vacia)
# let l3 = Cons (3, Vacia);;
val l3 : int lista = Cons (3, Vacia)
# let l33 = Cons (3, l3);;
val l33 : int lista = Cons (3, Cons (3, Vacia))

Tenemos las list definidas

El viernes nos contará algo que no viene definido el Ocaml.

árboles binarios

type 'a bintree = bien ejercicio pensarlo

Las listas son arboles unarios, con solo una rama


HA FALTADO EL VIERNES, LO SIENTO ALEX DEL FUTURO

siguiente clase 28 nov:

debio dar arboles binarios por lo que dijo
ahora está hablando de arbiles estrictamente binarios o no

type 'a bintree =
    Empty 
  | Node of 'a = 'a bintree * 'a bintree;;

let rec nodos = function
    Empty -> 0
  | Node (_,i,d) -> 1 + nnodos i + nnodos d;;

let rec altura = function
    Empty -> 0
  | Node (_,i,d) -> i + nnodos i + nnodos d;;

let rec tmax = function
    Empty -> raise (Invalid_argument "tmax")
  | Node me falta cosas



otro, esto era del otro día que no vine

Con esto voy a representar cualquier árbol estrictamente binario

type 'a st_bintree =
    Node of 'a * 'a st_bintree * 'a st_bintree
  | Leaf of 'a;;

let rec hojas = function
    Leaf v -> [v]
  | Node (_, i, d) -> hojas i @ hojas d;;

un árbol que no pueda tener el arbol vacio:

type 'a ne_bintree =
    Node of 'a * 'a ne_bintree option * 'a ne_bintree option;;

Entran todos menos los vacios

let leaf v = Node (v, []);;

let t_6 = Node (6,[leaf (5; lead 11)]);;

faltan cosas

let rec nnodos Node (_, lr) =
    List.fold_left (+) 1 List.map nnodos lr;;

let rec nnodos Node (_, lr) =
    List.fold_left (fun n t -> n + nodos t) 1 lr;;

cualquier árbol que tenga, al menos, una rama se puede dividir en 2 árboles, entonces:

let rec nnodos = function 
    Node (_, []) -> 1
  | Node (r, h::t) -> nnodos h + nnodos (Node (r, t));;

la mejor, la última, QUEDAN 6 CLASES AAAAAAAAAAAAAAAAAH

proxima día el lado oscuro, la parte imperativa del lenguaje, venir preparados

como se carga un módulo, #load "counter.cmo";;
Counter.next;;

Si no quiero poner counter pongo, open Counter;;


Otro día, falte el viernes, dio la aparte imperativa del lenguaje y ahora toca seguir
habla de ;

match <e> with es similar a un switch

vamos con los bucles:

<b> bool

while <b> do <e> done

cuando es false daria un unit y si no evalua e

let rec fact n =
  if n <= 0 then 1
  else n * fact (n-1);;

hacer esta función pero sin usar rec

un bucle sin variables no sirve para nadaw, en funcional algo que se evalue false o true siempre será false o true;

vamos alla:

let fact n = 
  let f = ref 1 in
  let i = ref 1 in 
  while !i <= n do
    f:= !f * !i;
    i := !i + 1
  done;
  !f;;

como vemos los bucles son más parecidos a la tail reculsion

let fect n =
  let rec aux (f,i) =
    if i <= n then
      aux (f * i, i + 1)
    else f
  in aux (1,1);;

bucle for:

for <i> = <i1> to <i2>
  do <e> done

for <i> = <i1> down to <i2>
  do <e> done

fact sin recursividad y sin el bucle while:

let fact n =
  let f = ref 1 in
  for i = 1 to n do
      f := !f * i
  done;
  !f;;

vamos a aumentar la diversión del imperactivo

let v = [|1; 10; 100|];;
val v : int array = [|1; 10; 100|]
no es una lista, mmmmmmmmmm
diferecias con la int list:
-rendimiento, en a' array puedes acceder al elemento de cualquiera posición con coste constante, adiferencia de las listas
-los array está numerados, de 0 a (n9-1)
-tambien tenemos el módulo Array

# Array.length;;
- : 'a array -> int = <fun>

# Array.get;;  (* Similar a nth pero co coste constante *)
- : 'a array -> int -> 'a = <fun>

abrebiado, v.(1);;

# v.(1);;
- : int = 10

recuerda que puedes dejar de llamar al modulp por Array.nombre con open Array

# open Array;;
# set v 2 (v.(1) + 2* v.(2));;
- : unit = ()
# v;;
- : int array = [|1; 10; 210|]

devuelve unit, pero no nos importa lo que devuelva, lo importante es que cambia v

v.(2) <- v.(1) + 2 * v.(2);; (* set abreviado *)

# v.(2) <- v.(1) + 2 * v.(2);;
- : unit = ()
# v;;
- : int array = [|1; 10; 430|]

existe init para array?

# Array.init 20 succ;;
- : int array =
[|1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20|]

# make 10_000 'a';;
- : char array =
[|'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a'; 'a';...|]

array de 10_000 char 'a', igual que el de List.make pero para Array

Array.copy hace una copia del array en ese momento

en rec con ! nos referimos al valor, similar a punteros parece, mirar.


TREMENDO PUENTE, VUELTA A CLASE, MARTES 12

type person = {name : string; age : int}

que es? un regustro de datos, un struct en C.

tiene 2 componentes un string y un int.

es un registro de 2 campos.

se puede hacer patermaching en los registros

older : person -> person

let order p =
  {name = p.name; age = p.age + 1};;

let older {name = n; age = a} =
  {name = n; age = a + 1};;

let older p =
  {p with age = p.age + 1; name = ""};;

puedo hacer otra definición de los registros:

type person = {name : string; mutable age : int}

let p2 : person = {name = "Marta"; age = 18}

como modifico el valor mutable?

p2.age <- 28;;

let aged p <- p.age + 1;;

aged p2; p2;; ahora así puedo imprimir el valor

type 'a var = {mutable valor : 'a};;

# {valor = 1};;
- : int var = {valor = 1}
# {valor = "Hola"};;
- : string var = {valor = "Hola"}

let initvar x = {valor = x};;

# initvar 10;;
- : int var = {valor = 10}
# initvar "Casa";;
- : string var = {valor = "Casa"}

let (!!) v = v.valor;;

let n = initvar 7;;

# let n = initvar 7;;
val n : int var = {valor = 7}
# !!n;;
- : int = 7

ACABO DE IMPLEMENTAR LAS VARIABLES EN OCAML, de hecho así están implementadas en Ocaml.

cambiamos de tema: ejemplo antiguo

la función next:

let n = ref 0

let next () = 
  n := !n + 1;
  !n

let reset () =
  n := 0

sin usar una variable global:

let next  =
  let n ref 0 in
    function () ->
    n := !n + 1;
    !n;;

pero como hacemos ahora el reset?

let next, reset =
  let n = ref 0 in
  (function () -> n := !n + 1; !n),
  (function () -> n := 0);;

  Otra menera seria usar un módulo

todo este tiempo con ocamlc algo.ml -i algo.mli estabamos compilando modulos

para cargarlos en el compilador interactivo #load "counter.cmo";;

entre comillas la ruta

HACER UN MÓDULO EN UN SOLO FICHERO:

module Contador : sig
  val next : unit -> int
  val reset : unit -> unit
end = struct
  let n = ref 0
  let next () = 
    n := !n + 1;
    !n
  let reset () =
    n := 0
end

esto es una fuctor, es como una funcion pero devuelve módulos

module Contador () : sig
  val next : unit -> int
  val reset : unit -> unit
end = struct
  let n = ref 0
  let next () = 
    n := !n + 1;
    !n
  let reset () =
    n := 0
end

module Contador :
  functor () -> sig val next : unit -> int val reset : unit -> unit end

# module Carne = Contador ();;
module Carne : sig val next : unit -> int val reset : unit -> unit end
# module Fruta = Contador ();;
module Fruta : sig val next : unit -> int val reset : unit -> unit end
# module Peixe = Contador ();;
module Peixe : sig val next : unit -> int val reset : unit -> unit end

BRUTAL

hay muchos módulos que no son módulos, son functor, entonces lo que pasa es que te crea modulos

OTRO DÍA VIERNES

habla de next, que se podŕia hacer con modulos

el uso de funtores, que son funciones que devuelven modulos, que si necesitamos varios next por ejemplo
los podría hacer con un funtor, en lugar de definir el modulo varias veces.

ESTES MODULOS PUEDEN FUNCIONAR COMO OBJETOS

los registros o structs en C, también podría funcionar next

type counter = {next : unit -> int ; reset: unit -> unit}

let counter = 
  let n = ref 0 in
  {next = (function () -> incr n; !n); 
   reset = (function () -> n := 0)};;

A todo esto existe la función incr;;
# incr;;
- : int ref -> unit = <fun>

# counter.next ();;
- : int = 1
# counter.next ();;
- : int = 2
# counter.next ();;
- : int = 3
# counter.next ();;
- : int = 4
# counter.next ();;
- : int = 5
# counter.reset ();;
- : unit = ()
# counter.next ();;
- : int = 1
# counter.next ();;
- : int = 2

lo mismo que con modulos

los registros pueden funcionar como módulos

también podría hacer una función que devuelva un counter, como con los funtores

let new_counter () =
  let n = ref 0 in
  {next = (function () -> incr n; !n); 
   reset = (function () -> n := 0)};;

# let c = new_counter ();;
val c : counter = {next = <fun>; reset = <fun>}
# let c' = new_counter ();;
val c' : counter = {next = <fun>; reset = <fun>}
# c.next ();;
- : int = 1
# c.next ();;
- : int = 2
# c'.next ();;
- : int = 1


VAMOS CON OBJETOS
en Ocaml no se suele usar por las formas alternativas de hacer las cosas

let counter = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

val counter : < next : int; reset : unit > = <obj>

2 métodos, el next y el reset

todos los objetos que tengan 2 metodos en ocaml son del mismo tipo

un propiedad de los obj es que cambian de estado, normalmente esto se representa con una variable, mutable
no es lo mismo que un 'a ref, es mucho más parecido a un registro "en C" o elementos de un vector

# counter#next;;
- : int = 1
# counter#next;;
- : int = 2
# counter#next;;
- : int = 3
# counter#next;;
- : int = 4
# counter#reset;;
- : unit = ()
# counter#next;;
- : int = 1
# counter#next;;
- : int = 2

se invocan con nombre del objeto#metodo

# counter#next;;
- : int = 4
# counter#next + (counter#reset; 2 * counter#next);;
- : int = 4

ojo, no ha dado 7, por que? por que se avalua primero la expresión de la derecha

MUCHO CUIDADO

let doble o = 2 * o#next;;

# let doble o = 2 * o#next;;
val doble : < next : int; .. > -> int = <fun>

POLIMORFIMOS CON OBJETOS ARRIBA, con registros no podría hacerlo, solo valdría para ese tipo de registros

# counter#next;;
- : int = 1
# doble counter;;
- : int = 4

let counter' = object
  val mutable n = 100
  method next = n <- n + 2 ; n    (* Suma 1 *)
end;;

val counter' : < next : int > = <obj>

# doble counter';;
- : int = 204

# doble counter';;
- : int = 208

counter y counter' no son del mismo tipo, pero gracias al polimorfismo en obj puedo aplicar la función doble,
está solo requiere que un obj tenga una función del tipo next de tipo int

let doble_o o = object
  val mutable n = o#next
  method next = n <- n + 3; n
end;;
val doble_o : < next : int; .. > -> < next : int > = <fun>

# doble_o counter;;
- : < next : int > = <obj>
# doble_o counter';;
- : < next : int > = <obj>

# let c3 = doble_o counter' ;;
val c3 : < next : int > = <obj>
# c3#next;;
- : int = 113

AHORA quiro crear varios obj del mismo tipo, como con los modulos y los registros
un función

let new_counter () = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

val new_counter : unit -> < next : int; reset : unit > = <fun>

# let c1 = new_counter ();;
val c1 : < next : int; reset : unit > = <obj>
# let c2 = new_counter ();;
val c2 : < next : int; reset : unit > = <obj>
# let c3 = new_counter ();;
val c3 : < next : int; reset : unit > = <obj>
# c1#next;;
- : int = 1
# c1#next;;
- : int = 2
# c2#next;;
- : int = 1
# c3#next;;
- : int = 1
# c3#next;;
- : int = 2
# c2#next;;
- : int = 2

c1, c2, c3 son del mismo tipo

# [c1;c2;c3];;
- : < next : int; reset : unit > list = [<obj>; <obj>; <obj>]

que falta aqui? las clases

que es una clase?
normalmente en los lenjuages orientados a abj tenemos que definiar la clase antes que los obj
aqui puedo tener obj sin clase, pero tambien existen las clases, en ocaml podría vivir sin las clases

las clases proporcionan la caracteristicas de la herencia, con la función new_counter no lo tengo
hasta ahora aqui hice objcetos inmediatos

como creo obj como clases?

una clase es una receta para crear obj

class new_counter = object
  val mutable n = 0
  method next = n <- n + 1 ; n    (* Suma 1 *)
  method reset = n <- 0           (* Resetea el contador a 0 *)
end;;

class new_counter :
  object val mutable n : int method next : int method reset : unit end

# let cc = new new_counter;;
val cc : new_counter = <obj>

# cc;;
- : new_counter = <obj>

cuando defino clases lo que estoy haciendo es definir un alias, para un tipo de obj, ahora new_counter es el nombre de los
obj que tienen el metodo reset y next

pero son del mismo tipo

# [c1;cc];;
- : new_counter list = [<obj>; <obj>]

---------------------------------------------
OTRO DÍA:
los objetos son valores, y hablamos del polimorfismo de los objetos

object atributos end

let c2 = new_counter ();;

para definir clases era:

new counter

class counter = object
	val mutable n = 0
	method next = n <- n + 1 ; n
	nethod reset : int
end;;

class counter_with_set = obsject
	inherit counter
	method set x = n <- x
end;;

algo de la clase counter_with_set no seria igual al tipo counter, pero lo podría restringir,
con:

c5 :> counter, siendo c5 un valor del tipo counter_with_set

entonces ahora podría hacer una lista de counter con c5

aunque en la lista se usa como  un counter, yo ouedo acceder a el con set y modificarlo y se modifica en la lista con set

ME MUERO PUTA MERDA DE CATARRO

inherit heredar de una clase anterior

se puede editar un clase, ej:

class counter_with_init ini = object (self)
	inherit counter_with_set
	method reset = (* n <- ini *)
			self#set ini
	initializer (* n <- ini *) self#reset
end;;

alias para hacer referencia a los elementos de la clase, metodo inicializador

un metodo permite una espacio de reculsibidad abierta

class counter_with_init'n'fin ini fin = object (self)
	inherit counter_with_init ini as super
	method next = let next = super#next in
		      if next < fin then next
		      else (self#reset; super#next)
end;;

se podría modificar el paso, un contador de step en step

class counter_with_step = object (self)
	inherit counter_with_init 0 as super
	val mutable step = 0
	method next = n <- n + step; n
	method set_step s = step <- s
	method reset = super#reset; self#set_step 1
end;;

esto como vemos es muy laborioso para hacer estas cosas, tenemos maneras más eficientes para la maquina y menos complicadas de escribir

esto tiene sentido sobre todo para interfaces web, donde tenemos widgets que se llaman etc.

en el moodle puso capitulos de libros que hablan más de objetos en ocaml, y las clases de la pandemia de objetos

polimorfismo con clases:

class ['a] stack =
	object
	   val mutable l = ([] : 'a list)	(* instance variable *)
	   method push x =
	      l <- x :: l
	   method pop = match l with 		(* push method *)
	      [] -> raise EmptyStack
	    | h::t -> l <- t; h
	   method peek = match l with		(* peek method *)
	      [] -> raise EmptyStack
            | h::_ -> h
end;;

maldita la falta que hacia definir esto como un objeto, dado que las listas en ocaml, ya trabajan como un stack


viernes no hay clase, materia por terminada, preguntemos lo que queramos por teams, día 30 es el límite

podemos traer notas apuntes, cosas que quepan en el pupitre y cada uno para si mismo xd

